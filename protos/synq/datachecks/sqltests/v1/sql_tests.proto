syntax = "proto3";

package synq.datachecks.sqltests.v1;

import "buf/validate/validate.proto";
import "google/protobuf/timestamp.proto";
import "synq/entities/v1/annotation.proto";
import "synq/entities/v1/identifier.proto";
import "synq/platforms/v1/data_platforms.proto";
import "synq/v1/source.proto";

option go_package = "github.com/getsynq/api/datachecks/sqltests/v1";

// The SqlTest is a SQL test that is executed on a synq entity.
message SqlTest {
  option (buf.validate.message).cel = {
    id: "sql_test_requires_expression_or_suggestion"
    expression: "has(this.sql_expression) != has(this.template)"
    message: "exactly one of sql_expression or template must be provided, but not both"
  };
  option (buf.validate.message).cel = {
    id: "sql_test_requires_platform_or_template"
    expression: "has(this.platform) || has(this.template.identifier)"
    message: "at least one of platform or template identifier must be provided"
  };

  // Identifier for the data platform which the SqlTest would be executed on.
  platforms.v1.DataPlatformIdentifier platform = 1;

  // Unique resource identifier for the SqlTest. This is externally maintained and can
  // be used to fetch/update/delete this test.
  string id = 2 [(buf.validate.field).required = true];

  // Human friendly name.
  string name = 3 [(buf.validate.field).required = true];

  // Description of purpose and motivation.
  string description = 9;

  Severity severity = 10;

  // A valid SQL expression which is the test.
  string sql_expression = 4;

  // [Recurrence rule](https://icalendar.org/iCalendar-RFC-5545/3-8-5-3-recurrence-rule.html) for the execution schedule of the SqlTest.
  string recurrence_rule = 5;

  // Annotations for the given SqlTest.These help filter the SqlTests for later
  // operations like listing by API, selection in UI, analytics, etc.
  repeated entities.v1.Annotation annotations = 6;

  // Boolean flag to to toggle saving of failure runs.
  bool save_failures = 7;

  // Template for the SqlTest.
  // required when sql_expression is not provided
  Template template = 8;

  // Config ID for the SqlTest.
  optional string config_id = 11;

  synq.v1.Source source = 12;
}

enum Severity {
  SEVERITY_UNSPECIFIED = 0;
  SEVERITY_WARNING = 1;
  SEVERITY_ERROR = 2;
  SEVERITY_INFO = 3;
}

message SqlTestAudit {
  string execution_id = 1;
  int32 rows_count = 2;
  string result = 3;
  google.protobuf.Timestamp created_at = 4;
}

// Represents a value that can be either a literal (to be quoted in SQL) or a SQL expression (to be used as plain text).
message SqlValue {
  option (buf.validate.message).oneof = {
    fields: ["string_literal", "expression"]
    required: true
  };
  // Literal value that should be quoted in SQL (e.g., '2025-05-12', 'active')
  string string_literal = 1;
  // SQL expression, numbers to be used as plain text (e.g., NOW(), COUNT(*), true, 1.1)
  string expression = 2;
}

message Template {
  // Read-only path of matched entity. This is a unique path that can be used to access the entity in the Synq's UI.
  synq.entities.v1.Identifier identifier = 1 [(buf.validate.field).required = true];
  oneof test {
    // Checks if specified columns contain no NULL values (e.g., user_id should never be null)
    NotNullTest not_null_test = 11;
    // Checks if specified columns contain empty values (e.g., description field can be empty)
    EmptyTest empty_test = 12;
    // Validates that column values are within an allowed set (e.g., status in ['active', 'inactive', 'pending'])
    AcceptedValuesTest accepted_values_test = 13;
    // Validates that column values are not in a forbidden set (e.g., country not in ['UNKNOWN', 'TEST'])
    RejectedValuesTest rejected_values_test = 14;
    // Ensures specified columns form a unique key combination (e.g., order_id is unique)
    UniqueTest unique_test = 15;
    // Checks if data is up-to-date based on a time column (e.g., latest event_timestamp within 24h)
    FreshnessTest freshness_test = 16;
    // Validates numeric values are within specified range (e.g., price between 0 and 1000)
    MinMaxTest min_max_test = 17;
    // Compares time-based columns for logical order (e.g., start_date before end_date)
    RelativeTimeTest relative_time_test = 18;
    // Custom SQL-based business logic validation (e.g., total_amount = subtotal + tax)
    BusinessRuleTest business_rule_test = 19;
    // Validates numeric values are greater than or equal to a minimum value (e.g., price &gt;= 0)
    MinValueTest min_value_test = 20;
    // Validates numeric values are less than or equal to a maximum value (e.g., price &lt;= 1000)
    MaxValueTest max_value_test = 21;
  }
}

message NotNullTest {
  // List of column names to check for NULL values
  repeated string column_names = 1 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.unique = true
  ];
}

message EmptyTest {
  // List of column names to check for empty values
  repeated string column_names = 1 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.unique = true
  ];
}

message AcceptedValuesTest {
  // Name of the column to validate
  string column_name = 1 [(buf.validate.field).required = true];
  // List of allowed values for the column
  repeated SqlValue accepted_values = 2 [
    (buf.validate.field).repeated.min_items = 1
  ];
}

message RejectedValuesTest {
  // Name of the column to validate
  string column_name = 1 [(buf.validate.field).required = true];
  // List of disallowed values for the column
  repeated SqlValue rejected_values = 2 [
    (buf.validate.field).repeated.min_items = 1
  ];
}

message MinMaxTest {
  // Name of the numeric column to validate
  string column_name = 1 [(buf.validate.field).required = true];
  // Minimum allowed value (inclusive)
  SqlValue min_value = 2;
  // Maximum allowed value (inclusive)
  SqlValue max_value = 3;
  // If true, bounds are exclusive
  bool strictly = 4;
}

message MinValueTest {
  // Name of the numeric column to validate
  string column_name = 1 [(buf.validate.field).required = true];
  // Minimum allowed value (inclusive)
  SqlValue min_value = 2;
  // If true, the minimum value is exclusive
  bool strictly = 3;
}

message MaxValueTest {
  // Name of the numeric column to validate
  string column_name = 1 [(buf.validate.field).required = true];
  // Maximum allowed value (inclusive)
  SqlValue max_value = 2;
  // If true, the maximum value is exclusive
  bool strictly = 3;
}

message UniqueTest {
  // List of columns that should form a unique combination
  repeated string column_names = 1 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.unique = true
  ];
  // If provided, the check will be applied to the time window of the time partition column
  // If not provided, the check will be applied to all rows
  string time_partition_column_name = 2;
  // Time window for uniqueness check (in seconds)
  int64 time_window_seconds = 3;
}

message FreshnessTest {
  // Name of the timestamp column used for freshness check
  string time_partition_column_name = 1 [(buf.validate.field).required = true];
  // Time window for freshness check (in seconds)
  int64 time_window_seconds = 2;
}

message CountDistinctTest {
  // List of columns to count distinct combinations
  repeated string column_names = 1 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.unique = true
  ];
}

message CountDuplicatesTest {
  // List of columns to check for duplicate combinations
  repeated string column_names = 1 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.unique = true
  ];
}

message RelativeTimeTest {
  // Name of the first time column to compare
  string column_name = 1 [(buf.validate.field).required = true];
  // Name of the second time column that should be later than the first
  string relative_column_name = 2 [(buf.validate.field).required = true];
}

message BusinessRuleTest {
  // SQL expression that should evaluate to TRUE for valid records
  string sql_expression = 1 [(buf.validate.field).required = true];
}
